<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>语义模型与技术元模型关系可视化</title>
    <link rel="stylesheet" href="styles.css" />
    <script src="d3.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #f5f5f5;
      }
      
      .header {
        background: white;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .header h1 {
        margin: 0 0 10px 0;
        color: #1e40af;
      }
      
      .header p {
        margin: 0;
        color: #6b7280;
      }
      
      .controls {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        display: flex;
        gap: 15px;
        align-items: center;
      }
      
      .controls button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        background: #3b82f6;
        color: white;
        cursor: pointer;
        font-size: 14px;
      }
      
      .controls button:hover {
        background: #2563eb;
      }
      
      .controls select {
        padding: 8px 12px;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        font-size: 14px;
      }
      
      .viz-container {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        min-height: 600px;
      }
      
      #graph {
        width: 100%;
        height: 800px;
        border: 1px solid #e5e7eb;
        border-radius: 4px;
      }
      
      .legend {
        margin-top: 20px;
        padding: 15px;
        background: #f9fafb;
        border-radius: 4px;
        display: flex;
        gap: 30px;
        flex-wrap: wrap;
      }
      
      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 1px solid #d1d5db;
      }
      
      .node {
        cursor: pointer;
      }
      
      .node.semantic {
        fill: #3b82f6;
        stroke: #1e40af;
        stroke-width: 2;
      }
      
      .node.technical {
        fill: #10b981;
        stroke: #059669;
        stroke-width: 2;
      }
      
      .node.attribute {
        fill: #f59e0b;
        stroke: #d97706;
        stroke-width: 1.5;
      }
      
      .node.column {
        fill: #ef4444;
        stroke: #dc2626;
        stroke-width: 1.5;
      }
      
      .link {
        stroke: #94a3b8;
        stroke-width: 2;
        fill: none;
        marker-end: url(#arrowhead);
      }
      
      .link.mapping {
        stroke: #8b5cf6;
        stroke-width: 3;
        stroke-dasharray: 5,5;
      }
      
      .link.relationship {
        stroke: #3b82f6;
        stroke-width: 2;
      }
      
      .link.foreign-key {
        stroke: #10b981;
        stroke-width: 2;
      }
      
      .node-label {
        font-size: 12px;
        font-weight: bold;
        pointer-events: none;
        fill: white;
        text-anchor: middle;
      }
      
      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>语义模型 ↔ 技术元模型关系可视化</h1>
      <p>展示 CIM 语义模型与 Iceberg 技术元模型之间的映射关系</p>
    </div>

    <div class="controls">
      <button onclick="loadVisualization()">重新加载</button>
      <select id="view-mode" onchange="updateViewMode()">
        <option value="full">完整视图</option>
        <option value="semantic">仅语义模型</option>
        <option value="technical">仅技术元模型</option>
        <option value="mapping">仅映射关系</option>
      </select>
      <span id="status"></span>
    </div>

    <div class="viz-container">
      <svg id="graph"></svg>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: #3b82f6;"></div>
        <span>语义实体 (Entity)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #10b981;"></div>
        <span>技术表 (Table)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #f59e0b;"></div>
        <span>语义属性 (Attribute)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ef4444;"></div>
        <span>技术列 (Column)</span>
      </div>
      <div class="legend-item">
        <div style="width: 30px; height: 2px; background: #8b5cf6; border: none;"></div>
        <span>映射关系 (Mapping)</span>
      </div>
      <div class="legend-item">
        <div style="width: 30px; height: 2px; background: #3b82f6; border: none;"></div>
        <span>语义关系 (Relationship)</span>
      </div>
      <div class="legend-item">
        <div style="width: 30px; height: 2px; background: #10b981; border: none;"></div>
        <span>外键关系 (Foreign Key)</span>
      </div>
    </div>

    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
      const API_BASE = "/api";
      let graphData = null;
      let currentViewMode = "full";

      // 加载可视化数据
      async function loadVisualization() {
        const statusEl = document.getElementById("status");
        statusEl.textContent = "加载中...";

        try {
          // 加载语义模型
          const entitiesRes = await fetch(`${API_BASE}/ontology/entities`);
          const entitiesData = await entitiesRes.json();

          // 加载所有映射关系
          const mappingsRes = await fetch(`${API_BASE}/tables/mappings`);
          const mappingsData = await mappingsRes.json();

          // 构建图数据（异步）
          graphData = await buildGraphData(entitiesData.entities, mappingsData.mappings);
          
          // 渲染图形
          renderGraph(graphData);
          
          statusEl.textContent = `已加载 ${entitiesData.entities.length} 个实体，${mappingsData.mappings.length} 个映射`;
        } catch (err) {
          console.error("加载失败:", err);
          statusEl.textContent = `加载失败: ${err.message}`;
        }
      }

      // 构建图数据（异步加载所有信息）
      async function buildGraphData(entities, mappings) {
        const nodes = [];
        const links = [];
        const nodeMap = new Map();

          // 创建语义实体节点（平衡的初始位置）
          entities.forEach((entity, idx) => {
            const nodeId = `semantic-${entity.name}`;
            nodes.push({
              id: nodeId,
              label: entity.name,
              type: "semantic-entity",
              data: entity,
              x: 150 + (idx % 4) * 160,  // 适度间距：120 -> 160，列数：5 -> 4
              y: 150 + Math.floor(idx / 4) * 120,  // 适度间距：100 -> 120
            });
            nodeMap.set(nodeId, nodes[nodes.length - 1]);

          // 创建属性节点（只显示关键属性，避免图形过于复杂）
          const keyAttrs = entity.key_attributes.slice(0, 3); // 只显示前3个关键属性
          keyAttrs.forEach((attr, attrIdx) => {
            const attrNodeId = `attr-${entity.name}-${attr}`;
            nodes.push({
              id: attrNodeId,
              label: attr,
              type: "semantic-attribute",
              data: { entity: entity.name, attribute: attr },
              x: 150 + (idx % 4) * 160 + (attrIdx % 3) * 50 - 50,  // 调整属性节点位置
              y: 150 + Math.floor(idx / 4) * 120 + 35 + Math.floor(attrIdx / 3) * 25,
            });
            nodeMap.set(attrNodeId, nodes[nodes.length - 1]);

            // 属性到实体的连接
            links.push({
              source: attrNodeId,
              target: nodeId,
              type: "attribute",
              label: "has",
            });
          });

          // 创建关系连接
          entity.relationships.forEach((rel) => {
            const targetEntityId = `semantic-${rel.target}`;
            // 检查目标实体是否存在（可能在当前实体列表中）
            const targetExists = entities.some((e) => e.name === rel.target);
            if (targetExists) {
              links.push({
                source: nodeId,
                target: targetEntityId,
                type: "relationship",
                label: rel.type,
              });
            }
          });
        });

        // 创建技术表节点和映射关系
        for (const mapping of mappings) {
          const tableNodeId = `table-${mapping.table_name}`;
          const entityName = mapping.entity_name;
          const semanticNodeId = `semantic-${entityName}`;

          // 创建表节点
          if (!nodeMap.has(tableNodeId)) {
            nodes.push({
              id: tableNodeId,
              label: mapping.table_name.split(".").pop(),
              type: "technical-table",
              data: mapping,
              x: (window.graphWidth || 1200) * 0.65 + (mappings.indexOf(mapping) % 4) * 160,  // 使用相对位置，适度间距
              y: 150 + Math.floor(mappings.indexOf(mapping) / 4) * 120,
            });
            nodeMap.set(tableNodeId, nodes[nodes.length - 1]);
          }

          // 创建映射关系（实体到表）
          if (nodeMap.has(semanticNodeId)) {
            links.push({
              source: semanticNodeId,
              target: tableNodeId,
              type: "mapping",
              label: "maps to",
            });
          }

          // 获取表的列信息
          try {
            const schemaRes = await fetch(`${API_BASE}/mapping/entity/${entityName}`);
            const schema = await schemaRes.json();

            // 创建列节点（只显示关键列，避免图形过于复杂）
            const keyColumns = schema.columns
              .filter((col) => !col.name.startsWith("valid_") && col.name !== "op_type" && col.name !== "ingestion_ts")
              .slice(0, 4); // 只显示前4个关键列

            keyColumns.forEach((col, colIdx) => {
              const colNodeId = `col-${mapping.table_name}-${col.name}`;
              if (!nodeMap.has(colNodeId)) {
                nodes.push({
                  id: colNodeId,
                  label: col.name,
                  type: "technical-column",
                  data: col,
                  x: (window.graphWidth || 1200) * 0.65 + (mappings.indexOf(mapping) % 4) * 160 + (colIdx % 3) * 50 - 50,
                  y: 150 + Math.floor(mappings.indexOf(mapping) / 4) * 120 + 35 + Math.floor(colIdx / 3) * 25,
                });
                nodeMap.set(colNodeId, nodes[nodes.length - 1]);

                // 列到表的连接
                links.push({
                  source: colNodeId,
                  target: tableNodeId,
                  type: "column",
                  label: "has",
                });
              }
            });
          } catch (err) {
            console.error(`加载 ${entityName} 的列信息失败:`, err);
          }
        }

        return { nodes, links };
      }

      // 渲染图形
      function renderGraph(data) {
        const svg = d3.select("#graph");
        svg.selectAll("*").remove();

        const width = svg.node().getBoundingClientRect().width || 1200;
        const height = 800;
        
        // 存储宽度供后续使用
        window.graphWidth = width;

        svg.attr("width", width).attr("height", height);

        // 添加箭头标记
        svg.append("defs")
          .append("marker")
          .attr("id", "arrowhead")
          .attr("viewBox", "-0 -5 10 10")
          .attr("refX", 15)
          .attr("refY", 0)
          .attr("orient", "auto")
          .attr("markerWidth", 6)
          .attr("markerHeight", 6)
          .append("path")
          .attr("d", "M 0,-5 L 10,0 L 0,5")
          .attr("fill", "#94a3b8");

        // 根据视图模式过滤数据
        const filteredData = filterByViewMode(data);

        // 创建力导向图（平衡布局）
        const simulation = d3.forceSimulation(filteredData.nodes)
          .force("link", d3.forceLink(filteredData.links).id((d) => d.id).distance((d) => {
            // 根据连线类型设置不同距离
            if (d.type === "mapping") return 120;  // 映射关系稍远
            if (d.type === "relationship") return 80;  // 语义关系中等
            return 50;  // 属性/列关系较近
          }))
          .force("charge", d3.forceManyBody().strength((d) => {
            // 根据节点类型设置不同排斥力
            if (d.type === "semantic-entity" || d.type === "technical-table") return -200;
            return -100;  // 小节点排斥力更小
          }))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius((d) => {
            // 根据节点类型设置碰撞半径
            if (d.type === "semantic-entity" || d.type === "technical-table") return 40;
            return 22;  // 小节点碰撞半径更小
          }))
          .force("x", d3.forceX(width / 2).strength(0.05))  // 减小X方向约束强度
          .force("y", d3.forceY(height / 2).strength(0.05));  // 减小Y方向约束强度

        // 绘制连线
        const link = svg.append("g")
          .selectAll("line")
          .data(filteredData.links)
          .enter()
          .append("line")
          .attr("class", (d) => {
            if (d.type === "mapping") return "link mapping";
            if (d.type === "relationship") return "link relationship";
            if (d.type === "foreign-key") return "link foreign-key";
            return "link";
          })
          .attr("stroke-width", (d) => {
            if (d.type === "mapping") return 3;
            return 2;
          })
          .attr("stroke-dasharray", (d) => {
            if (d.type === "mapping") return "5,5";
            return "none";
          });

        // 绘制节点
        const node = svg.append("g")
          .selectAll("circle")
          .data(filteredData.nodes)
          .enter()
          .append("circle")
          .attr("class", (d) => {
            if (d.type === "semantic-entity") return "node semantic";
            if (d.type === "technical-table") return "node technical";
            if (d.type === "semantic-attribute") return "node attribute";
            if (d.type === "technical-column") return "node column";
            return "node";
          })
          .attr("r", (d) => {
            if (d.type === "semantic-entity" || d.type === "technical-table") return 25;
            return 15;
          })
          .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
          .on("mouseover", showTooltip)
          .on("mouseout", hideTooltip);

        // 添加标签
        const label = svg.append("g")
          .selectAll("text")
          .data(filteredData.nodes)
          .enter()
          .append("text")
          .attr("class", "node-label")
          .text((d) => d.label)
          .attr("font-size", (d) => {
            if (d.type === "semantic-entity" || d.type === "technical-table") return "14px";
            return "11px";
          })
          .attr("fill", (d) => {
            if (d.type === "semantic-attribute" || d.type === "technical-column") return "#1f2937";
            return "white";
          });

        // 添加连线标签
        const linkLabel = svg.append("g")
          .selectAll("text")
          .data(filteredData.links.filter((d) => d.type === "mapping" || d.type === "relationship"))
          .enter()
          .append("text")
          .attr("class", "link-label")
          .text((d) => d.label || d.type)
          .attr("font-size", "10px")
          .attr("fill", "#6b7280")
          .attr("text-anchor", "middle");

        // 更新位置
        simulation.on("tick", () => {
          link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);

          node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
          label.attr("x", (d) => d.x).attr("y", (d) => d.y + 5);
          
          linkLabel
            .attr("x", (d) => (d.source.x + d.target.x) / 2)
            .attr("y", (d) => (d.source.y + d.target.y) / 2);
        });
        
        // 设置适中的收敛速度
        simulation.alphaDecay(0.03);  // 默认是 0.0228，稍微加快收敛但保持平滑

        // 拖拽函数
        function dragstarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }

        function dragged(event, d) {
          d.fx = event.x;
          d.fy = event.y;
        }

        function dragended(event, d) {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        }

        // 工具提示
        function showTooltip(event, d) {
          const tooltip = d3.select("#tooltip");
          let content = `<strong>${d.label}</strong><br>`;
          
          if (d.type === "semantic-entity") {
            content += `类型: 语义实体<br>`;
            content += `属性: ${d.data.all_attributes?.length || 0} 个<br>`;
            content += `关系: ${d.data.relationships?.length || 0} 个`;
          } else if (d.type === "technical-table") {
            content += `类型: 技术表<br>`;
            content += `命名空间: ${d.data.namespace}<br>`;
            content += `列数: ${d.data.column_count || 0}`;
          } else if (d.type === "semantic-attribute") {
            content += `类型: 语义属性<br>`;
            content += `实体: ${d.data.entity}`;
          } else if (d.type === "technical-column") {
            content += `类型: 技术列<br>`;
            content += `数据类型: ${d.data.type}`;
          }
          
          tooltip
            .style("display", "block")
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 10) + "px")
            .html(content);
        }

        function hideTooltip() {
          d3.select("#tooltip").style("display", "none");
        }
      }

      // 根据视图模式过滤数据
      function filterByViewMode(data) {
        if (currentViewMode === "full") {
          return data;
        }

        const filteredNodes = [];
        const filteredLinks = [];
        const nodeSet = new Set();

        if (currentViewMode === "semantic") {
          // 只显示语义模型
          data.nodes.forEach((node) => {
            if (node.type.startsWith("semantic")) {
              filteredNodes.push(node);
              nodeSet.add(node.id);
            }
          });
          data.links.forEach((link) => {
            if (link.type === "relationship" || link.type === "attribute") {
              if (nodeSet.has(link.source.id) && nodeSet.has(link.target.id)) {
                filteredLinks.push(link);
              }
            }
          });
        } else if (currentViewMode === "technical") {
          // 只显示技术元模型
          data.nodes.forEach((node) => {
            if (node.type.startsWith("technical")) {
              filteredNodes.push(node);
              nodeSet.add(node.id);
            }
          });
          data.links.forEach((link) => {
            if (link.type === "column" || link.type === "foreign-key") {
              if (nodeSet.has(link.source.id) && nodeSet.has(link.target.id)) {
                filteredLinks.push(link);
              }
            }
          });
        } else if (currentViewMode === "mapping") {
          // 只显示映射关系
          data.links.forEach((link) => {
            if (link.type === "mapping") {
              filteredLinks.push(link);
              nodeSet.add(link.source.id);
              nodeSet.add(link.target.id);
            }
          });
          data.nodes.forEach((node) => {
            if (nodeSet.has(node.id)) {
              filteredNodes.push(node);
            }
          });
        }

        return { nodes: filteredNodes, links: filteredLinks };
      }

      // 更新视图模式
      function updateViewMode() {
        currentViewMode = document.getElementById("view-mode").value;
        if (graphData) {
          renderGraph(graphData);
        }
      }

      // 页面加载时自动加载
      loadVisualization();
    </script>
  </body>
</html>

